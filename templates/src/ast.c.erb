#include "rbs/ast.h"
#include <stdlib.h>

/* rbs_node */

<%- nodes.each do |node| -%>
<%= node.c_type_name %> *<%= node.c_constructor_function_name %>(<%= node.fields.map { |field| "VALUE #{field.name}" }.join(", ") %>) {
    <%= node.c_type_name %> *node = malloc(sizeof(<%= node.c_type_name %>));

    *node = (<%= node.c_type_name %>) {
        .base = (rbs_node_t) {
            .type = <%= node.c_type_enum_name %>
        },
        <%- node.fields.each do |field| -%>
        .<%= field.name %> = <%= field.name %>,
        <%- end -%>
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    <%- node.fields.each do |field| -%>
    rb_gc_register_address(&node-><%= field.name %>);
    <%- end -%>

    return node;
}

<%- end -%>

/* rbs_node_instance_wrapper */

rbs_node_instance_wrapper_t *rbs_node_instance_wrapper_new(VALUE instance) {
    rbs_node_instance_wrapper_t *node = malloc(sizeof(rbs_node_instance_wrapper_t));

    *node = (rbs_node_instance_wrapper_t) {
        .base = (rbs_node_t) {
            .type = RBS_NODE_INSTANCE_WRAPPER
        },
        .instance = instance
    };

    rb_gc_register_address(&node->instance);

    return node;
}
