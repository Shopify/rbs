#include "rbs/ast.h"

#include <stdlib.h>
#include "rbs/ruby_objs.h"
#include "rbs/constants.h"

/* rbs_node_list */

rbs_node_list_t* rbs_node_list_new(void) {
    rbs_node_list_t *list = (rbs_node_list_t *)malloc(sizeof(rbs_node_list_t));
    list->head = NULL;
    list->tail = NULL;
    list->length = 0;
    list->cached_ruby_value = rb_ary_new();

    rb_gc_register_mark_object(list->cached_ruby_value);

    return list;
}

void rbs_node_list_free(rbs_node_list_t *list) {
    rbs_node_list_node_t *current = list->head;
    while (current != NULL) {
        rbs_node_list_node_t *next = current->next;
        free(current);
        current = next;
    }
    free(list);
}

void rbs_node_list_append(rbs_node_list_t *list, rbs_node_t *node) {
    rb_gc_register_mark_object(node->cached_ruby_value);

    rbs_node_list_node_t *new_node = (rbs_node_list_node_t *)malloc(sizeof(rbs_node_list_node_t));
    new_node->node = node;
    new_node->next = NULL;

    if (list->tail == NULL) {
        list->head = new_node;
        list->tail = new_node;
    } else {
        list->tail->next = new_node;
        list->tail = new_node;
    }
    list->length++;

    rb_ary_push(list->cached_ruby_value, node->cached_ruby_value);
}

VALUE rbs_node_list_to_ruby_array(rbs_node_list_t *list) {
    return list->cached_ruby_value;
}

/* rbs_hash */

rbs_hash_t* rbs_hash_new(void) {
    rbs_hash_t *hash = (rbs_hash_t *)malloc(sizeof(rbs_hash_t));
    hash->head = NULL;
    hash->tail = NULL;
    hash->length = 0;
    hash->cached_ruby_value = rb_hash_new();

    rb_gc_register_mark_object(hash->cached_ruby_value);

    return hash;
}

void rbs_hash_free(rbs_hash_t *hash) {
    rbs_hash_node_t *current = hash->head;
    while (current != NULL) {
        rbs_hash_node_t *next = current->next;
        free(current);
        current = next;
    }
    free(hash);
}

rbs_hash_node_t* rbs_hash_find(rbs_hash_t *hash, rbs_node_t *key) {
    rbs_hash_node_t *current = hash->head;

    while (current != NULL) {
        if (rb_equal(key->cached_ruby_value, current->key->cached_ruby_value)) {
            return current;
        }
        current = current->next;
    }

    return NULL;
}

void rbs_hash_set(rbs_hash_t *hash, rbs_node_t *key, rbs_node_t *value) {
    rb_gc_register_mark_object(key->cached_ruby_value);
    rb_gc_register_mark_object(value->cached_ruby_value);

    rbs_hash_node_t *existing_node = rbs_hash_find(hash, key);
    if (existing_node != NULL) {
        existing_node->value = value;
        return;
    }

    rb_hash_aset(hash->cached_ruby_value, key->cached_ruby_value, value->cached_ruby_value);

    rbs_hash_node_t *new_node = (rbs_hash_node_t *)malloc(sizeof(rbs_hash_node_t));
    new_node->key = key;
    new_node->value = value;
    new_node->next = NULL;

    if (hash->tail == NULL) {
        hash->head = new_node;
        hash->tail = new_node;
    } else {
        hash->tail->next = new_node;
        hash->tail = new_node;
    }
}

rbs_node_t* rbs_hash_get(rbs_hash_t *hash, rbs_node_t *key) {
    rbs_hash_node_t *node = rbs_hash_find(hash, key);
    return node ? node->value : NULL;
}

VALUE rbs_hash_to_ruby_hash(rbs_hash_t *hash) {
    return hash->cached_ruby_value;
}

<%-
nodes.each do |node|

parameters = node.constructor_parameters
-%>
<%= node.c_type_name %> *<%= node.c_constructor_function_name %>(<%= parameters.map(&:parameter_decl).join(", ") %>) {
    <%= node.c_type_name %> *instance = (<%= node.c_type_name %> *)calloc(1, sizeof(<%= node.c_type_name %>));

    // Disable GC for all these Ruby objects.
    <%- parameters.each do |parameter| -%>
    rb_gc_register_mark_object(<%= parameter.cached_ruby_value_expr %>);
    <%- end -%>

    <%- if node.builds_ruby_object_internally? -%>
    // Generate our own Ruby VALUE here, rather than accepting it from a parameter.
    <%- if node.c_type_name == "rbs_ast_bool_t" -%>
    VALUE ruby_value = value ? Qtrue : Qfalse;
    <%- else -%>
    VALUE ruby_value = <%= node.c_function_name %>(<%= parameters.map(&:name).join(", ") %>);
    <%- end -%>
    <%- end -%>

    rb_gc_register_mark_object(ruby_value);

    *instance = (<%= node.c_type_name %>) {
        .base = (rbs_node_t) {
            .cached_ruby_value = ruby_value,
            .type = <%= node.c_type_enum_name %>
        },
        <%- node.fields.each do |field| -%>
        .<%= field.name %> = <%= field.name %>,
        <%- end -%>
    };

    return instance;
}

<%- end -%>

#ifdef RB_PASS_KEYWORDS
  // Ruby 2.7 or later
  #define CLASS_NEW_INSTANCE(klass, argc, argv)\
          rb_class_new_instance_kw(argc, argv, klass, RB_PASS_KEYWORDS)
#else
  // Ruby 2.6
  #define CLASS_NEW_INSTANCE(receiver, argc, argv)\
          rb_class_new_instance(argc, argv, receiver)
#endif

const char* get_class_name(VALUE o) {
    VALUE klass = rb_class_of(o);      // Get the class of the object
    VALUE klass_name = rb_class_name(klass);  // Get the name of the class
    const char* name = StringValueCStr(klass_name);  // Convert to C string
    return name;
}

VALUE rbs_struct_to_ruby_value(rbs_node_t *instance) {
    if (instance == NULL) {
        return Qnil;
    }

    VALUE ruby_value = instance->cached_ruby_value;

    if (ruby_value == Qnil || ruby_value == Qundef) {
        fprintf(stderr, "cached_ruby_value is NULL\n");
        exit(1);
    }

    const char *class_name = get_class_name(ruby_value);

    switch (instance->type) {
        <%- nodes.each do |node| -%>
        case <%= node.c_type_enum_name %>: {
            <%-
            rbs_struct_to_ruby_value_shitlist = [
                "RBS::AST::Bool",
                "RBS::AST::Symbol",
                "RBS::AST::Declarations::Nodes",
                "RBS::AST::Directives::Nodes",
                "RBS::Types::Record::FieldType",
            ]

            if rbs_struct_to_ruby_value_shitlist.include?(node.ruby_full_name) -%>
            return instance->cached_ruby_value;
            <%- else -%>
            if (strcmp(class_name, "<%= node.ruby_full_name %>") != 0) {
                fprintf(stderr, "Expected class name: <%= node.ruby_full_name %>, got %s\n", class_name);
                exit(1);
            }
            <%- if node.fields.any? -%> <%# This prevents "warning: unused variable 'node'" %>
            <%= node.c_type_name %> *node = (<%= node.c_type_name %> *)instance;
            <%- end -%>
            // <%= node.fields.inspect %>
            VALUE h = rb_hash_new();
            <%- node.fields.each do |field| -%>
            <%- case field.c_type -%>
            <%- when "VALUE" -%>
            rb_hash_aset(h, ID2SYM(rb_intern("<%= field.name %>")), node-><%= field.name %>);
            <%- when "rbs_node_list" -%>
            rb_hash_aset(h, ID2SYM(rb_intern("<%= field.name %>")), rbs_node_list_to_ruby_array(node-><%= field.name %>));
            <%- when "rbs_hash" -%>
            rb_hash_aset(h, ID2SYM(rb_intern("<%= field.name %>")), rbs_hash_to_ruby_hash(node-><%= field.name %>));
            <%- when "rbs_location" -%>
            rb_hash_aset(h, ID2SYM(rb_intern("<%= field.name %>")), rbs_loc_to_ruby_location(node-><%= field.name %>));
            <%- when "comment" -%>
            rb_hash_aset(h, ID2SYM(rb_intern("<%= field.name %>")), node-><%= field.name %>->string);
            <%- when "bool" -%>
            rb_hash_aset(h, ID2SYM(rb_intern("<%= field.name %>")), node-><%= field.name %> ? Qtrue : Qfalse);
            <%- else -%>
            <%- unless field.ast_node? -%>
            #warning unexpected type <%= field.c_type -%>
            <%- end -%>
            rb_hash_aset(h, ID2SYM(rb_intern("<%= field.name %>")), rbs_struct_to_ruby_value((rbs_node_t *) node-><%= field.name %>)); // <%= field.c_type %>
            <%- end -%>
            <%- end -%>

            return CLASS_NEW_INSTANCE(
                <%= node.c_constant_name %>,
                1,
                &h
            );
            <%- end -%>
        }
        <%- end -%>
    }
}
