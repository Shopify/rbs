#include "rbs/ast.h"

#include "rbs/ruby_objs.h"

#include <ruby/encoding.h>

/* rbs_node_list */

rbs_node_list_t* rbs_node_list_new(rbs_allocator_t *allocator) {
    rbs_node_list_t *list = rbs_allocator_alloc(allocator, rbs_node_list_t);
    *list = (rbs_node_list_t) {
        .allocator = allocator,
        .head = NULL,
        .tail = NULL,
        .length = 0,
        .cached_ruby_value = rb_ary_new(),
    };

    rb_gc_register_mark_object(list->cached_ruby_value);

    return list;
}

void rbs_node_list_append(rbs_node_list_t *list, rbs_node_t *node) {
    rb_gc_register_mark_object(node->cached_ruby_value);

    rbs_node_list_node_t *new_node = rbs_allocator_alloc(list->allocator, rbs_node_list_node_t);
    *new_node = (rbs_node_list_node_t) {
        .node = node,
        .next = NULL,
    };

    if (list->tail == NULL) {
        list->head = new_node;
        list->tail = new_node;
    } else {
        list->tail->next = new_node;
        list->tail = new_node;
    }
    list->length++;

    rb_ary_push(list->cached_ruby_value, node->cached_ruby_value);
}

/* rbs_hash */

rbs_hash_t* rbs_hash_new(rbs_allocator_t *allocator) {
    rbs_hash_t *hash = rbs_allocator_alloc(allocator, rbs_hash_t);
    *hash = (rbs_hash_t) {
        .allocator = allocator,
        .head = NULL,
        .tail = NULL,
        .length = 0,
        .cached_ruby_value = rb_hash_new(),
    };

    rb_gc_register_mark_object(hash->cached_ruby_value);

    return hash;
}

bool rbs_node_equal(rbs_node_t *lhs, rbs_node_t *rhs) {
    if (lhs == rhs) return true;
    if (lhs->type != rhs->type) return false;

    switch (lhs->type) {
    case RBS_AST_SYMBOL:
        return ((rbs_ast_symbol_t *)lhs)->constant_id == ((rbs_ast_symbol_t *) rhs)->constant_id;
    case RBS_KEYWORD:
        return ((rbs_keyword_t *)lhs)->constant_id == ((rbs_keyword_t *) rhs)->constant_id;
    case RBS_AST_BOOL:
        return ((rbs_ast_bool_t *)lhs)->value == ((rbs_ast_bool_t *) rhs)->value;
    case RBS_OTHER_RUBY_VALUE:
        return rb_equal(((rbs_other_ruby_value_t *) lhs)->base.cached_ruby_value, ((rbs_other_ruby_value_t *) rhs)->base.cached_ruby_value);
    default:
        return rb_equal(lhs->cached_ruby_value, rhs->cached_ruby_value);
    }
}

rbs_hash_node_t* rbs_hash_find(rbs_hash_t *hash, rbs_node_t *key) {
    rbs_hash_node_t *current = hash->head;

    while (current != NULL) {
        if (rbs_node_equal(key, current->key)) {
            return current;
        }
        current = current->next;
    }

    return NULL;
}

void rbs_hash_set(rbs_hash_t *hash, rbs_node_t *key, rbs_node_t *value) {
    rb_gc_register_mark_object(key->cached_ruby_value);
    rb_gc_register_mark_object(value->cached_ruby_value);

    rbs_hash_node_t *existing_node = rbs_hash_find(hash, key);
    if (existing_node != NULL) {
        existing_node->value = value;
        return;
    }

    rb_hash_aset(hash->cached_ruby_value, key->cached_ruby_value, value->cached_ruby_value);

    rbs_hash_node_t *new_node = rbs_allocator_alloc(hash->allocator, rbs_hash_node_t);
    new_node->key = key;
    new_node->value = value;
    new_node->next = NULL;

    if (hash->tail == NULL) {
        hash->head = new_node;
        hash->tail = new_node;
    } else {
        hash->tail->next = new_node;
        hash->tail = new_node;
    }
}

rbs_node_t* rbs_hash_get(rbs_hash_t *hash, rbs_node_t *key) {
    rbs_hash_node_t *node = rbs_hash_find(hash, key);
    return node ? node->value : NULL;
}

rbs_keyword_t *rbs_keyword_new(rbs_allocator_t *allocator, rbs_constant_id_t constant_id) {
    rbs_keyword_t *instance = rbs_allocator_alloc(allocator, rbs_keyword_t);

    rbs_constant_t *constant = rbs_constant_pool_id_to_constant(RBS_GLOBAL_CONSTANT_POOL, constant_id);
    assert(constant != NULL && "constant is NULL");
    assert(constant->start != NULL && "constant->start is NULL");

    *instance = (rbs_keyword_t) {
        .base = (rbs_node_t) {
            .cached_ruby_value = ID2SYM(rb_intern2((const char *) constant->start, constant->length)),
            .type = RBS_KEYWORD,
        },
        .constant_id = constant_id,
    };

    return instance;
}

rbs_ast_symbol_t *rbs_ast_symbol_new(rbs_allocator_t *allocator, rbs_constant_pool_t *constant_pool, rbs_constant_id_t constant_id) {
    rbs_ast_symbol_t *instance = rbs_allocator_alloc(allocator, rbs_ast_symbol_t);

    rbs_constant_t *constant = rbs_constant_pool_id_to_constant(constant_pool, constant_id);
    assert(constant != NULL && "constant is NULL");
    assert(constant->start != NULL && "constant->start is NULL");

    // FIXME: Replace this with the encoding used by the input buffer.
    rb_encoding *encoding = rb_usascii_encoding();

    *instance = (rbs_ast_symbol_t) {
        .base = (rbs_node_t) {
            .cached_ruby_value = ID2SYM(rb_intern3((const char *) constant->start, constant->length, encoding)),
            .type = RBS_AST_SYMBOL,
        },
        .constant_id = constant_id,
    };

    return instance;
}

rbs_other_ruby_value_t *rbs_other_ruby_value_new(VALUE ruby_value) {
    rbs_other_ruby_value_t *instance = malloc(sizeof(rbs_other_ruby_value_t));

    *instance = (rbs_other_ruby_value_t) {
        .base = (rbs_node_t) {
            .cached_ruby_value = ruby_value,
            .type = RBS_OTHER_RUBY_VALUE
        },
    };

    return instance;
}


<%- nodes.each do |node| -%>
<%= node.c_type_name %> *<%= node.c_constructor_function_name %>(<%= node.constructor_params.map(&:parameter_decl).join(", ") %>) {
    <%= node.c_type_name %> *instance = rbs_allocator_alloc(allocator, <%= node.c_type_name %>);

    // Disable GC for all these Ruby objects.
    <%- node.fields.each do |field| -%>
    rb_gc_register_mark_object(<%= field.cached_ruby_value_expr %>);
    <%- end -%>

    <%- if node.builds_ruby_object_internally? -%>
    // Generate our own Ruby VALUE here, rather than accepting it from a parameter.
    <%- if node.c_type_name == "rbs_ast_bool_t" -%>
    VALUE ruby_value = value ? Qtrue : Qfalse;
    <%- else -%>
    VALUE ruby_value = <%= node.c_function_name %>(<%= node.fields.map(&:name).join(", ") %>);
    <%- end -%>
    <%- end -%>

    rb_gc_register_mark_object(ruby_value);

    *instance = (<%= node.c_type_name %>) {
        .base = (rbs_node_t) {
            .cached_ruby_value = ruby_value,
            .type = <%= node.c_type_enum_name %>
        },
        <%- node.fields.each do |field| -%>
        .<%= field.name %> = <%= field.name %>,
        <%- end -%>
    };

    return instance;
}

<%- end -%>
