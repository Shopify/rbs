#line <%= __LINE__ + 1 %> "prism/templates/src/<%= File.basename(__FILE__) %>"
#include "rbs/ast.h"

#include <stdio.h>
#include <stdlib.h>

const char* rbs_node_type_name(rbs_node_t *node) {
    switch (node->type) {
        <%- nodes.each do |node| -%>
        case <%= node.c_type_enum_name %>: return "<%= node.ruby_full_name %>";
        <%- end -%>
        case RBS_AST_SYMBOL: return "Symbol";
        default: return "Unknown";
    }
}

/* rbs_node_list */

rbs_node_list_t* rbs_node_list_new(void) {
    rbs_node_list_t *list = (rbs_node_list_t *)malloc(sizeof(rbs_node_list_t));
    list->head = NULL;
    list->tail = NULL;
    list->length = 0;

    return list;
}

void rbs_node_list_free(rbs_node_list_t *list) {
    rbs_node_list_node_t *current = list->head;
    while (current != NULL) {
        rbs_node_list_node_t *next = current->next;
        rbs_node_destroy(current->node);
        free(current);
        current = next;
    }
    free(list);
}

void rbs_node_list_append(rbs_node_list_t *list, rbs_node_t *node) {
    rbs_node_list_node_t *new_node = (rbs_node_list_node_t *)malloc(sizeof(rbs_node_list_node_t));
    new_node->node = node;
    new_node->next = NULL;

    if (list->tail == NULL) {
        list->head = new_node;
        list->tail = new_node;
    } else {
        list->tail->next = new_node;
        list->tail = new_node;
    }

    list->length++;
}

/* rbs_hash */

rbs_hash_t* rbs_hash_new(void) {
    rbs_hash_t *hash = (rbs_hash_t *)malloc(sizeof(rbs_hash_t));
    hash->head = NULL;
    hash->tail = NULL;
    hash->length = 0;

    return hash;
}

void rbs_hash_free(rbs_hash_t *hash) {
    rbs_hash_node_t *current = hash->head;
    while (current != NULL) {
        rbs_hash_node_t *next = current->next;
        rbs_node_destroy(current->key);
        rbs_node_destroy(current->value);
        free(current);
        current = next;
    }
    free(hash);
}

bool rbs_node_equal(rbs_node_t *lhs, rbs_node_t *rhs) {
    if (lhs == rhs) return true;
    if (lhs->type != rhs->type) return false;

    switch (lhs->type) {
        case RBS_AST_BOOL:
            return ((rbs_ast_bool_t *)lhs)->value == ((rbs_ast_bool_t *) rhs)->value;
        case RBS_AST_INTEGER:
            return rbs_string_equal(((rbs_ast_integer_t *) lhs)->string_representation, ((rbs_ast_integer_t *) rhs)->string_representation);
        case RBS_AST_SYMBOL: {
            return rbs_constant_id_equal(
                fake_constant_pool,
                ((rbs_ast_symbol_t *) lhs)->constant_id,
                ((rbs_ast_symbol_t *) rhs)->constant_id
            );
        }
        case RBS_AST_STRING: {
            return rbs_string_equal(((rbs_ast_string_t *) lhs)->string, ((rbs_ast_string_t *) rhs)->string);
        }
        default:
            printf("Unhandled node type: %d\n", lhs->type);
            return false;
    }
}

rbs_hash_node_t* rbs_hash_find(rbs_hash_t *hash, rbs_node_t *key) {
    rbs_hash_node_t *current = hash->head;

    while (current != NULL) {
        if (rbs_node_equal(key, current->key)) {
            return current;
        }
        current = current->next;
    }

    return NULL;
}

void rbs_hash_set(rbs_hash_t *hash, rbs_node_t *key, rbs_node_t *value) {
    rbs_hash_node_t *existing_node = rbs_hash_find(hash, key);
    if (existing_node != NULL) {
        existing_node->value = value;
        return;
    }

    rbs_hash_node_t *new_node = (rbs_hash_node_t *)malloc(sizeof(rbs_hash_node_t));
    new_node->key = key;
    new_node->value = value;
    new_node->next = NULL;

    if (hash->tail == NULL) {
        hash->head = new_node;
        hash->tail = new_node;
    } else {
        hash->tail->next = new_node;
        hash->tail = new_node;
    }
}

rbs_node_t* rbs_hash_get(rbs_hash_t *hash, rbs_node_t *key) {
    rbs_hash_node_t *node = rbs_hash_find(hash, key);
    return node ? node->value : NULL;
}

rbs_ast_symbol_t *rbs_ast_symbol_new(rbs_location_t *location, rbs_constant_id_t constant_id) {
    rbs_ast_symbol_t *instance = (rbs_ast_symbol_t *)calloc(1, sizeof(rbs_ast_symbol_t));

    *instance = (rbs_ast_symbol_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_SYMBOL,
            .location = location,
        },
        .constant_id = constant_id,
    };

    return instance;
}

<%- nodes.each do |node| -%>
#line <%= __LINE__ + 1 %> "prism/templates/src/<%= File.basename(__FILE__) %>"
<%= node.c_type_name %> *<%= node.c_constructor_function_name %>(rbs_location_t *location<%= node.fields.any? ? ", " : "" %><%= node.fields.map(&:parameter_decl).join(", ") %>) {
    <%= node.c_type_name %> *instance = (<%= node.c_type_name %> *)calloc(1, sizeof(<%= node.c_type_name %>));

    <%- node.fields.each do |field| -%>
    <%- if field.c_type == "VALUE" -%>
    rb_gc_register_mark_object(<%= field.c_name %>);
    <%- end -%>
    <%- end -%>

    *instance = (<%= node.c_type_name %>) {
        .base = (rbs_node_t) {
            .type = <%= node.c_type_enum_name %>,
            .location = location,
        },
        <%- node.fields.each do |field| -%>
        .<%= field.c_name %> = <%= field.c_name %>,
        <%- end -%>
    };

    return instance;
}
<%- end -%>

#line <%= __LINE__ + 1 %> "prism/templates/src/<%= File.basename(__FILE__) %>"
void rbs_node_destroy(rbs_node_t *any_node) {
    switch (any_node->type) {
    <%- nodes.each do |node| -%>
#line <%= __LINE__ + 1 %> "prism/templates/src/<%= File.basename(__FILE__) %>"
    case <%= node.c_type_enum_name %>: {
        <%- if node.has_children_to_free? -%>
        <%= node.c_type_name %> *node = (<%= node.c_type_name %> *)any_node;

        <%- node.fields.each do |field| -%>
        <%- case field.c_type -%>
        <%- when "rbs_string" -%>
        rbs_string_free(&node-><%= field.c_name %>);
        <%- when "rbs_node_list" -%>
        rbs_node_list_free(node-><%= field.c_name %>);
        <%- when "rbs_hash" -%>
        rbs_hash_free(node-><%= field.c_name %>);
        <%- when "bool" -%>
        // <%= field.c_name %> is a bool, so we don't need to free it.
        <%- else -%>
        if (node-><%= field.c_name %> != NULL) {
            rbs_node_destroy((rbs_node_t *) node-><%= field.c_name %>);
        }
        <%- end -%>
        <%- end -%>
        <%- end -%>
        break;
    }
    <%- end -%>
    case RBS_AST_SYMBOL: {
        rbs_ast_symbol_t *node = (rbs_ast_symbol_t *) any_node;
        pm_constant_pool_destroy_constant(fake_constant_pool, node->constant_id);
        break;
    }
    }

    free(any_node);
}
