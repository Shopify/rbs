#include "ast_translation.h"
#include "rbs_extension.h"

#ifdef RB_PASS_KEYWORDS
// Ruby 2.7 or later
#define CLASS_NEW_INSTANCE(klass, argc, argv)\
        rb_class_new_instance_kw(argc, argv, klass, RB_PASS_KEYWORDS)
#else
// Ruby 2.6
#define CLASS_NEW_INSTANCE(receiver, argc, argv)\
        rb_class_new_instance(argc, argv, receiver)
#endif

const char* get_class_name(VALUE o) {
    VALUE klass = rb_class_of(o);      // Get the class of the object
    VALUE klass_name = rb_class_name(klass);  // Get the name of the class
    const char* name = StringValueCStr(klass_name);  // Convert to C string
    return name;
}

VALUE rbs_struct_to_ruby_value(rbs_node_t *node) {
    if(node == NULL) {
        fprintf(stderr, "Attempted to convert NULL node to Ruby value\n");
        exit(1);
    }

    switch (node->type) {
        <%- nodes.each do |node| -%>
        case <%= node.c_type_enum_name %>: {
            <%= node.c_type_name %> *typed_node = (<%= node.c_type_name %> *)node;

            VALUE _init_kwargs = rb_hash_new();
            <%- node.fields.each do |field| -%>
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("<%= field.name %>")), typed_node-><%= field.name %>);
            <%- end -%>

            VALUE instance = CLASS_NEW_INSTANCE(
                <%= node.c_constant_name %>,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            <%- node.fields.each do |field| -%>
            rb_gc_unregister_address(&typed_node-><%= field.name %>);
            <%- end -%>

            free(node);

            return instance;
        }
        <%- end -%>
        case RBS_NODE_INSTANCE_WRAPPER: {
            rbs_node_instance_wrapper_t *wrapper = (rbs_node_instance_wrapper_t *)node;
            VALUE instance = wrapper->instance;
            rb_gc_unregister_address(&wrapper->instance);
            free(wrapper);
            return instance;
        }
    }

    fprintf(stderr, "Unknown node type: %d\n", node->type);
    exit(1);
}
