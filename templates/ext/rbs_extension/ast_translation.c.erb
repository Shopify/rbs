#include "ast_translation.h"
#include "rbs_extension.h"

#ifdef RB_PASS_KEYWORDS
// Ruby 2.7 or later
#define CLASS_NEW_INSTANCE(klass, argc, argv)\
        rb_class_new_instance_kw(argc, argv, klass, RB_PASS_KEYWORDS)
#else
// Ruby 2.6
#define CLASS_NEW_INSTANCE(receiver, argc, argv)\
        rb_class_new_instance(argc, argv, receiver)
#endif

const char* get_class_name(VALUE o) {
    VALUE klass = rb_class_of(o);      // Get the class of the object
    VALUE klass_name = rb_class_name(klass);  // Get the name of the class
    const char* name = StringValueCStr(klass_name);  // Convert to C string
    return name;
}

VALUE rbs_struct_to_ruby_value(rbs_node_t *instance) {
    switch (instance->type) {
        <%- nodes.each do |node| -%>
        case <%= node.c_type_enum_name %>: {
            <%= node.c_type_name %> *node = (<%= node.c_type_name %> *)instance;

            VALUE _init_kwargs = rb_hash_new();
            <%- node.fields.each do |field| -%>
            <%- if field.c_type == "VALUE" -%>
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("<%= field.name %>")), node-><%= field.name %>);
            <%- else -%>
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("<%= field.name %>")), rbs_struct_to_ruby_value(node-><%= field.name %>));
            <%- end -%>
            <%- end -%>

            VALUE obj = CLASS_NEW_INSTANCE(
                <%= node.c_constant_name %>,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            <%- node.fields.each do |field| -%>
            <%- if field.c_type == "VALUE" -%>
            rb_gc_unregister_address(&node-><%= field.name %>);
            <%- end -%>
            <%- end -%>

            free(instance);

            return obj;
        }
        <%- end -%>
        case RBS_NODE_INSTANCE_WRAPPER: {
            rbs_node_instance_wrapper_t *wrapper = (rbs_node_instance_wrapper_t *)instance;
            rb_gc_unregister_address(&wrapper->instance);
            return wrapper->instance;
        }
    }

    fprintf(stderr, "Unknown node type: %d\n", instance->type);
    exit(1);
}
