/*----------------------------------------------------------------------------*/
/* This file is generated by the templates/template.rb script and should not  */
/* be modified manually.                                                      */
/* To change the template see                                                 */
/* templates/ext/rbs_extension/ast_translation.c.erb                          */
/*----------------------------------------------------------------------------*/

#include "ast_translation.h"
#include "rbs_extension.h"

#ifdef RB_PASS_KEYWORDS
// Ruby 2.7 or later
#define CLASS_NEW_INSTANCE(klass, argc, argv)\
        rb_class_new_instance_kw(argc, argv, klass, RB_PASS_KEYWORDS)
#else
// Ruby 2.6
#define CLASS_NEW_INSTANCE(receiver, argc, argv)\
        rb_class_new_instance(argc, argv, receiver)
#endif

const char* get_class_name(VALUE o) {
    VALUE klass = rb_class_of(o);      // Get the class of the object
    VALUE klass_name = rb_class_name(klass);  // Get the name of the class
    const char* name = StringValueCStr(klass_name);  // Convert to C string
    return name;
}

VALUE rbs_struct_to_ruby_value(rbs_node_t *node) {
    if(node == NULL) {
        fprintf(stderr, "Attempted to convert NULL node to Ruby value\n");
        exit(1);
    }

    switch (node->type) {
        case RBS_AST_ANNOTATION: {
            rbs_ast_annotation_t *typed_node = (rbs_ast_annotation_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("string")), typed_node->string);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Annotation,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->string);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_AST_COMMENT: {
            rbs_ast_comment_t *typed_node = (rbs_ast_comment_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("string")), typed_node->string);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Comment,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->string);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_AST_DECLARATIONS_CLASS: {
            rbs_ast_declarations_class_t *typed_node = (rbs_ast_declarations_class_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type_params")), typed_node->type_params);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("super_class")), typed_node->super_class);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("members")), typed_node->members);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("annotations")), typed_node->annotations);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("comment")), typed_node->comment);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Declarations_Class,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->type_params);
            rb_gc_unregister_address(&typed_node->super_class);
            rb_gc_unregister_address(&typed_node->members);
            rb_gc_unregister_address(&typed_node->annotations);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->comment);

            free(node);

            return instance;
        }
        case RBS_AST_DECLARATIONS_CLASS_SUPER: {
            rbs_ast_declarations_class_super_t *typed_node = (rbs_ast_declarations_class_super_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("args")), typed_node->args);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Declarations_Class_Super,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->args);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_AST_DECLARATIONS_CLASS_ALIAS: {
            rbs_ast_declarations_class_alias_t *typed_node = (rbs_ast_declarations_class_alias_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("new_name")), typed_node->new_name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("old_name")), typed_node->old_name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("comment")), typed_node->comment);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Declarations_ClassAlias,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->new_name);
            rb_gc_unregister_address(&typed_node->old_name);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->comment);

            free(node);

            return instance;
        }
        case RBS_AST_DECLARATIONS_CONSTANT: {
            rbs_ast_declarations_constant_t *typed_node = (rbs_ast_declarations_constant_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type")), typed_node->type);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("comment")), typed_node->comment);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Declarations_Constant,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->type);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->comment);

            free(node);

            return instance;
        }
        case RBS_AST_DECLARATIONS_GLOBAL: {
            rbs_ast_declarations_global_t *typed_node = (rbs_ast_declarations_global_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type")), typed_node->type);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("comment")), typed_node->comment);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Declarations_Global,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->type);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->comment);

            free(node);

            return instance;
        }
        case RBS_AST_DECLARATIONS_INTERFACE: {
            rbs_ast_declarations_interface_t *typed_node = (rbs_ast_declarations_interface_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type_params")), typed_node->type_params);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("members")), typed_node->members);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("annotations")), typed_node->annotations);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("comment")), typed_node->comment);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Declarations_Interface,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->type_params);
            rb_gc_unregister_address(&typed_node->members);
            rb_gc_unregister_address(&typed_node->annotations);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->comment);

            free(node);

            return instance;
        }
        case RBS_AST_DECLARATIONS_MODULE: {
            rbs_ast_declarations_module_t *typed_node = (rbs_ast_declarations_module_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type_params")), typed_node->type_params);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("self_types")), typed_node->self_types);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("members")), typed_node->members);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("annotations")), typed_node->annotations);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("comment")), typed_node->comment);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Declarations_Module,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->type_params);
            rb_gc_unregister_address(&typed_node->self_types);
            rb_gc_unregister_address(&typed_node->members);
            rb_gc_unregister_address(&typed_node->annotations);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->comment);

            free(node);

            return instance;
        }
        case RBS_AST_DECLARATIONS_MODULE_SELF: {
            rbs_ast_declarations_module_self_t *typed_node = (rbs_ast_declarations_module_self_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("args")), typed_node->args);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Declarations_Module_Self,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->args);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_AST_DECLARATIONS_MODULE_ALIAS: {
            rbs_ast_declarations_module_alias_t *typed_node = (rbs_ast_declarations_module_alias_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("new_name")), typed_node->new_name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("old_name")), typed_node->old_name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("comment")), typed_node->comment);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Declarations_ModuleAlias,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->new_name);
            rb_gc_unregister_address(&typed_node->old_name);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->comment);

            free(node);

            return instance;
        }
        case RBS_AST_DECLARATIONS_TYPE_ALIAS: {
            rbs_ast_declarations_type_alias_t *typed_node = (rbs_ast_declarations_type_alias_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type_params")), typed_node->type_params);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type")), typed_node->type);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("annotations")), typed_node->annotations);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("comment")), typed_node->comment);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Declarations_TypeAlias,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->type_params);
            rb_gc_unregister_address(&typed_node->type);
            rb_gc_unregister_address(&typed_node->annotations);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->comment);

            free(node);

            return instance;
        }
        case RBS_AST_DIRECTIVES_USE: {
            rbs_ast_directives_use_t *typed_node = (rbs_ast_directives_use_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("clauses")), typed_node->clauses);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Directives_Use,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->clauses);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_AST_DIRECTIVES_USE_SINGLE_CLAUSE: {
            rbs_ast_directives_use_single_clause_t *typed_node = (rbs_ast_directives_use_single_clause_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type_name")), typed_node->type_name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("new_name")), typed_node->new_name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Directives_Use_SingleClause,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->type_name);
            rb_gc_unregister_address(&typed_node->new_name);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_AST_DIRECTIVES_USE_WILDCARD_CLAUSE: {
            rbs_ast_directives_use_wildcard_clause_t *typed_node = (rbs_ast_directives_use_wildcard_clause_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("namespace")), typed_node->namespace);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Directives_Use_WildcardClause,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->namespace);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_AST_MEMBERS_ALIAS: {
            rbs_ast_members_alias_t *typed_node = (rbs_ast_members_alias_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("new_name")), typed_node->new_name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("old_name")), typed_node->old_name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("kind")), typed_node->kind);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("annotations")), typed_node->annotations);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("comment")), typed_node->comment);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Members_Alias,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->new_name);
            rb_gc_unregister_address(&typed_node->old_name);
            rb_gc_unregister_address(&typed_node->kind);
            rb_gc_unregister_address(&typed_node->annotations);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->comment);

            free(node);

            return instance;
        }
        case RBS_AST_MEMBERS_ATTR_ACCESSOR: {
            rbs_ast_members_attr_accessor_t *typed_node = (rbs_ast_members_attr_accessor_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type")), typed_node->type);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("ivar_name")), typed_node->ivar_name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("kind")), typed_node->kind);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("annotations")), typed_node->annotations);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("comment")), typed_node->comment);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("visibility")), typed_node->visibility);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Members_AttrAccessor,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->type);
            rb_gc_unregister_address(&typed_node->ivar_name);
            rb_gc_unregister_address(&typed_node->kind);
            rb_gc_unregister_address(&typed_node->annotations);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->comment);
            rb_gc_unregister_address(&typed_node->visibility);

            free(node);

            return instance;
        }
        case RBS_AST_MEMBERS_ATTR_READER: {
            rbs_ast_members_attr_reader_t *typed_node = (rbs_ast_members_attr_reader_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type")), typed_node->type);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("ivar_name")), typed_node->ivar_name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("kind")), typed_node->kind);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("annotations")), typed_node->annotations);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("comment")), typed_node->comment);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("visibility")), typed_node->visibility);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Members_AttrReader,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->type);
            rb_gc_unregister_address(&typed_node->ivar_name);
            rb_gc_unregister_address(&typed_node->kind);
            rb_gc_unregister_address(&typed_node->annotations);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->comment);
            rb_gc_unregister_address(&typed_node->visibility);

            free(node);

            return instance;
        }
        case RBS_AST_MEMBERS_ATTR_WRITER: {
            rbs_ast_members_attr_writer_t *typed_node = (rbs_ast_members_attr_writer_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type")), typed_node->type);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("ivar_name")), typed_node->ivar_name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("kind")), typed_node->kind);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("annotations")), typed_node->annotations);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("comment")), typed_node->comment);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("visibility")), typed_node->visibility);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Members_AttrWriter,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->type);
            rb_gc_unregister_address(&typed_node->ivar_name);
            rb_gc_unregister_address(&typed_node->kind);
            rb_gc_unregister_address(&typed_node->annotations);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->comment);
            rb_gc_unregister_address(&typed_node->visibility);

            free(node);

            return instance;
        }
        case RBS_AST_MEMBERS_CLASS_INSTANCE_VARIABLE: {
            rbs_ast_members_class_instance_variable_t *typed_node = (rbs_ast_members_class_instance_variable_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type")), typed_node->type);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("comment")), typed_node->comment);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Members_ClassInstanceVariable,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->type);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->comment);

            free(node);

            return instance;
        }
        case RBS_AST_MEMBERS_CLASS_VARIABLE: {
            rbs_ast_members_class_variable_t *typed_node = (rbs_ast_members_class_variable_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type")), typed_node->type);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("comment")), typed_node->comment);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Members_ClassVariable,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->type);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->comment);

            free(node);

            return instance;
        }
        case RBS_AST_MEMBERS_EXTEND: {
            rbs_ast_members_extend_t *typed_node = (rbs_ast_members_extend_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("args")), typed_node->args);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("annotations")), typed_node->annotations);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("comment")), typed_node->comment);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Members_Extend,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->args);
            rb_gc_unregister_address(&typed_node->annotations);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->comment);

            free(node);

            return instance;
        }
        case RBS_AST_MEMBERS_INCLUDE: {
            rbs_ast_members_include_t *typed_node = (rbs_ast_members_include_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("args")), typed_node->args);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("annotations")), typed_node->annotations);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("comment")), typed_node->comment);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Members_Include,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->args);
            rb_gc_unregister_address(&typed_node->annotations);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->comment);

            free(node);

            return instance;
        }
        case RBS_AST_MEMBERS_INSTANCE_VARIABLE: {
            rbs_ast_members_instance_variable_t *typed_node = (rbs_ast_members_instance_variable_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type")), typed_node->type);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("comment")), typed_node->comment);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Members_InstanceVariable,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->type);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->comment);

            free(node);

            return instance;
        }
        case RBS_AST_MEMBERS_METHOD_DEFINITION: {
            rbs_ast_members_method_definition_t *typed_node = (rbs_ast_members_method_definition_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("kind")), typed_node->kind);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("overloads")), typed_node->overloads);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("annotations")), typed_node->annotations);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("comment")), typed_node->comment);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("overloading")), typed_node->overloading);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("visibility")), typed_node->visibility);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Members_MethodDefinition,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->kind);
            rb_gc_unregister_address(&typed_node->overloads);
            rb_gc_unregister_address(&typed_node->annotations);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->comment);
            rb_gc_unregister_address(&typed_node->overloading);
            rb_gc_unregister_address(&typed_node->visibility);

            free(node);

            return instance;
        }
        case RBS_AST_MEMBERS_METHOD_DEFINITION_OVERLOAD: {
            rbs_ast_members_method_definition_overload_t *typed_node = (rbs_ast_members_method_definition_overload_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("annotations")), typed_node->annotations);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("method_type")), typed_node->method_type);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Members_MethodDefinition_Overload,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->annotations);
            rb_gc_unregister_address(&typed_node->method_type);

            free(node);

            return instance;
        }
        case RBS_AST_MEMBERS_PREPEND: {
            rbs_ast_members_prepend_t *typed_node = (rbs_ast_members_prepend_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("args")), typed_node->args);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("annotations")), typed_node->annotations);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("comment")), typed_node->comment);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Members_Prepend,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->args);
            rb_gc_unregister_address(&typed_node->annotations);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->comment);

            free(node);

            return instance;
        }
        case RBS_AST_MEMBERS_PRIVATE: {
            rbs_ast_members_private_t *typed_node = (rbs_ast_members_private_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Members_Private,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_AST_MEMBERS_PUBLIC: {
            rbs_ast_members_public_t *typed_node = (rbs_ast_members_public_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_Members_Public,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_AST_TYPE_PARAM: {
            rbs_ast_type_param_t *typed_node = (rbs_ast_type_param_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("variance")), typed_node->variance);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("upper_bound")), typed_node->upper_bound);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("default_type")), typed_node->default_type);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("unchecked")), typed_node->unchecked);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_AST_TypeParam,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->variance);
            rb_gc_unregister_address(&typed_node->upper_bound);
            rb_gc_unregister_address(&typed_node->default_type);
            rb_gc_unregister_address(&typed_node->unchecked);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_METHOD_TYPE: {
            rbs_method_type_t *typed_node = (rbs_method_type_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type_params")), typed_node->type_params);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type")), typed_node->type);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("block")), typed_node->block);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_MethodType,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->type_params);
            rb_gc_unregister_address(&typed_node->type);
            rb_gc_unregister_address(&typed_node->block);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_NAMESPACE: {
            rbs_namespace_t *typed_node = (rbs_namespace_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("path")), typed_node->path);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("absolute")), typed_node->absolute);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Namespace,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->path);
            rb_gc_unregister_address(&typed_node->absolute);

            free(node);

            return instance;
        }
        case RBS_TYPE_NAME: {
            rbs_type_name_t *typed_node = (rbs_type_name_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("namespace")), typed_node->namespace);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_TypeName,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->namespace);
            rb_gc_unregister_address(&typed_node->name);

            free(node);

            return instance;
        }
        case RBS_TYPES_ALIAS: {
            rbs_types_alias_t *typed_node = (rbs_types_alias_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("args")), typed_node->args);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Alias,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->args);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_BASES_ANY: {
            rbs_types_bases_any_t *typed_node = (rbs_types_bases_any_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("todo")), typed_node->todo);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Bases_Any,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->todo);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_BASES_BOOL: {
            rbs_types_bases_bool_t *typed_node = (rbs_types_bases_bool_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Bases_Bool,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_BASES_BOTTOM: {
            rbs_types_bases_bottom_t *typed_node = (rbs_types_bases_bottom_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Bases_Bottom,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_BASES_CLASS: {
            rbs_types_bases_class_t *typed_node = (rbs_types_bases_class_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Bases_Class,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_BASES_INSTANCE: {
            rbs_types_bases_instance_t *typed_node = (rbs_types_bases_instance_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Bases_Instance,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_BASES_NIL: {
            rbs_types_bases_nil_t *typed_node = (rbs_types_bases_nil_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Bases_Nil,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_BASES_SELF: {
            rbs_types_bases_self_t *typed_node = (rbs_types_bases_self_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Bases_Self,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_BASES_TOP: {
            rbs_types_bases_top_t *typed_node = (rbs_types_bases_top_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Bases_Top,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_BASES_VOID: {
            rbs_types_bases_void_t *typed_node = (rbs_types_bases_void_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Bases_Void,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_BLOCK: {
            rbs_types_block_t *typed_node = (rbs_types_block_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type")), typed_node->type);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("required")), typed_node->required);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("self_type")), typed_node->self_type);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Block,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->type);
            rb_gc_unregister_address(&typed_node->required);
            rb_gc_unregister_address(&typed_node->self_type);

            free(node);

            return instance;
        }
        case RBS_TYPES_CLASS_INSTANCE: {
            rbs_types_class_instance_t *typed_node = (rbs_types_class_instance_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("args")), typed_node->args);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_ClassInstance,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->args);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_CLASS_SINGLETON: {
            rbs_types_class_singleton_t *typed_node = (rbs_types_class_singleton_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_ClassSingleton,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_FUNCTION: {
            rbs_types_function_t *typed_node = (rbs_types_function_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("required_positionals")), typed_node->required_positionals);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("optional_positionals")), typed_node->optional_positionals);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("rest_positionals")), typed_node->rest_positionals);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("trailing_positionals")), typed_node->trailing_positionals);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("required_keywords")), typed_node->required_keywords);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("optional_keywords")), typed_node->optional_keywords);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("rest_keywords")), typed_node->rest_keywords);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("return_type")), typed_node->return_type);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Function,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->required_positionals);
            rb_gc_unregister_address(&typed_node->optional_positionals);
            rb_gc_unregister_address(&typed_node->rest_positionals);
            rb_gc_unregister_address(&typed_node->trailing_positionals);
            rb_gc_unregister_address(&typed_node->required_keywords);
            rb_gc_unregister_address(&typed_node->optional_keywords);
            rb_gc_unregister_address(&typed_node->rest_keywords);
            rb_gc_unregister_address(&typed_node->return_type);

            free(node);

            return instance;
        }
        case RBS_TYPES_FUNCTION_PARAM: {
            rbs_types_function_param_t *typed_node = (rbs_types_function_param_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type")), typed_node->type);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Function_Param,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->type);
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_INTERFACE: {
            rbs_types_interface_t *typed_node = (rbs_types_interface_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("args")), typed_node->args);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Interface,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->args);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_INTERSECTION: {
            rbs_types_intersection_t *typed_node = (rbs_types_intersection_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("types")), typed_node->types);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Intersection,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->types);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_LITERAL: {
            rbs_types_literal_t *typed_node = (rbs_types_literal_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("literal")), typed_node->literal);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Literal,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->literal);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_OPTIONAL: {
            rbs_types_optional_t *typed_node = (rbs_types_optional_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type")), typed_node->type);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Optional,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->type);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_PROC: {
            rbs_types_proc_t *typed_node = (rbs_types_proc_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("type")), typed_node->type);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("block")), typed_node->block);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("self_type")), typed_node->self_type);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Proc,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->type);
            rb_gc_unregister_address(&typed_node->block);
            rb_gc_unregister_address(&typed_node->location);
            rb_gc_unregister_address(&typed_node->self_type);

            free(node);

            return instance;
        }
        case RBS_TYPES_RECORD: {
            rbs_types_record_t *typed_node = (rbs_types_record_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("all_fields")), typed_node->all_fields);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Record,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->all_fields);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_TUPLE: {
            rbs_types_tuple_t *typed_node = (rbs_types_tuple_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("types")), typed_node->types);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Tuple,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->types);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_UNION: {
            rbs_types_union_t *typed_node = (rbs_types_union_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("types")), typed_node->types);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Union,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->types);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_TYPES_UNTYPED_FUNCTION: {
            rbs_types_untyped_function_t *typed_node = (rbs_types_untyped_function_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("return_type")), typed_node->return_type);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_UntypedFunction,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->return_type);

            free(node);

            return instance;
        }
        case RBS_TYPES_VARIABLE: {
            rbs_types_variable_t *typed_node = (rbs_types_variable_t *)node;

            VALUE _init_kwargs = rb_hash_new();
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("name")), typed_node->name);
            rb_hash_aset(_init_kwargs, ID2SYM(rb_intern("location")), typed_node->location);

            VALUE instance = CLASS_NEW_INSTANCE(
                RBS_Types_Variable,
                1,
                &_init_kwargs
            );

            // TODO: remove this once we do not use inner Ruby objects in our nodes.
            // Unmark the fields we previously marked as live during the node C struct creation (see `ast.c.erb`).
            // Now that we have created the Ruby object to hold the inner VALUE objects the GC won't collect them until
            // the Ruby instance is collected.
            rb_gc_unregister_address(&typed_node->name);
            rb_gc_unregister_address(&typed_node->location);

            free(node);

            return instance;
        }
        case RBS_NODE_INSTANCE_WRAPPER: {
            rbs_node_instance_wrapper_t *wrapper = (rbs_node_instance_wrapper_t *)node;
            VALUE instance = wrapper->instance;
            rb_gc_unregister_address(&wrapper->instance);
            free(wrapper);
            return instance;
        }
    }

    fprintf(stderr, "Unknown node type: %d\n", node->type);
    exit(1);
}
