/*----------------------------------------------------------------------------*/
/* This file is generated by the templates/template.rb script and should not  */
/* be modified manually.                                                      */
/* To change the template see                                                 */
/* templates/src/ast.c.erb                                                    */
/*----------------------------------------------------------------------------*/

#include "rbs/ast.h"
#include <stdlib.h>

rbs_ast_annotation_t *rbs_ast_annotation_new(VALUE string, VALUE location) {
    rbs_ast_annotation_t *instance = malloc(sizeof(rbs_ast_annotation_t));

    *instance = (rbs_ast_annotation_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_ANNOTATION
        },
        .string = string,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->string);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_ast_comment_t *rbs_ast_comment_new(VALUE string, VALUE location) {
    rbs_ast_comment_t *instance = malloc(sizeof(rbs_ast_comment_t));

    *instance = (rbs_ast_comment_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_COMMENT
        },
        .string = string,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->string);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_ast_declarations_class_t *rbs_ast_declarations_class_new(VALUE name, VALUE type_params, VALUE super_class, VALUE members, VALUE annotations, VALUE location, VALUE comment) {
    rbs_ast_declarations_class_t *instance = malloc(sizeof(rbs_ast_declarations_class_t));

    *instance = (rbs_ast_declarations_class_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_DECLARATIONS_CLASS
        },
        .name = name,
        .type_params = type_params,
        .super_class = super_class,
        .members = members,
        .annotations = annotations,
        .location = location,
        .comment = comment,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->type_params);
    rb_gc_register_address(&instance->super_class);
    rb_gc_register_address(&instance->members);
    rb_gc_register_address(&instance->annotations);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->comment);

    return instance;
}

rbs_ast_declarations_class_super_t *rbs_ast_declarations_class_super_new(VALUE name, VALUE args, VALUE location) {
    rbs_ast_declarations_class_super_t *instance = malloc(sizeof(rbs_ast_declarations_class_super_t));

    *instance = (rbs_ast_declarations_class_super_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_DECLARATIONS_CLASS_SUPER
        },
        .name = name,
        .args = args,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->args);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_ast_declarations_class_alias_t *rbs_ast_declarations_class_alias_new(VALUE new_name, VALUE old_name, VALUE location, VALUE comment) {
    rbs_ast_declarations_class_alias_t *instance = malloc(sizeof(rbs_ast_declarations_class_alias_t));

    *instance = (rbs_ast_declarations_class_alias_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_DECLARATIONS_CLASS_ALIAS
        },
        .new_name = new_name,
        .old_name = old_name,
        .location = location,
        .comment = comment,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->new_name);
    rb_gc_register_address(&instance->old_name);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->comment);

    return instance;
}

rbs_ast_declarations_constant_t *rbs_ast_declarations_constant_new(VALUE name, VALUE type, VALUE location, VALUE comment) {
    rbs_ast_declarations_constant_t *instance = malloc(sizeof(rbs_ast_declarations_constant_t));

    *instance = (rbs_ast_declarations_constant_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_DECLARATIONS_CONSTANT
        },
        .name = name,
        .type = type,
        .location = location,
        .comment = comment,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->type);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->comment);

    return instance;
}

rbs_ast_declarations_global_t *rbs_ast_declarations_global_new(VALUE name, VALUE type, VALUE location, VALUE comment) {
    rbs_ast_declarations_global_t *instance = malloc(sizeof(rbs_ast_declarations_global_t));

    *instance = (rbs_ast_declarations_global_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_DECLARATIONS_GLOBAL
        },
        .name = name,
        .type = type,
        .location = location,
        .comment = comment,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->type);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->comment);

    return instance;
}

rbs_ast_declarations_interface_t *rbs_ast_declarations_interface_new(VALUE name, VALUE type_params, VALUE members, VALUE annotations, VALUE location, VALUE comment) {
    rbs_ast_declarations_interface_t *instance = malloc(sizeof(rbs_ast_declarations_interface_t));

    *instance = (rbs_ast_declarations_interface_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_DECLARATIONS_INTERFACE
        },
        .name = name,
        .type_params = type_params,
        .members = members,
        .annotations = annotations,
        .location = location,
        .comment = comment,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->type_params);
    rb_gc_register_address(&instance->members);
    rb_gc_register_address(&instance->annotations);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->comment);

    return instance;
}

rbs_ast_declarations_module_t *rbs_ast_declarations_module_new(VALUE name, VALUE type_params, VALUE self_types, VALUE members, VALUE annotations, VALUE location, VALUE comment) {
    rbs_ast_declarations_module_t *instance = malloc(sizeof(rbs_ast_declarations_module_t));

    *instance = (rbs_ast_declarations_module_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_DECLARATIONS_MODULE
        },
        .name = name,
        .type_params = type_params,
        .self_types = self_types,
        .members = members,
        .annotations = annotations,
        .location = location,
        .comment = comment,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->type_params);
    rb_gc_register_address(&instance->self_types);
    rb_gc_register_address(&instance->members);
    rb_gc_register_address(&instance->annotations);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->comment);

    return instance;
}

rbs_ast_declarations_module_self_t *rbs_ast_declarations_module_self_new(VALUE name, VALUE args, VALUE location) {
    rbs_ast_declarations_module_self_t *instance = malloc(sizeof(rbs_ast_declarations_module_self_t));

    *instance = (rbs_ast_declarations_module_self_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_DECLARATIONS_MODULE_SELF
        },
        .name = name,
        .args = args,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->args);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_ast_declarations_module_alias_t *rbs_ast_declarations_module_alias_new(VALUE new_name, VALUE old_name, VALUE location, VALUE comment) {
    rbs_ast_declarations_module_alias_t *instance = malloc(sizeof(rbs_ast_declarations_module_alias_t));

    *instance = (rbs_ast_declarations_module_alias_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_DECLARATIONS_MODULE_ALIAS
        },
        .new_name = new_name,
        .old_name = old_name,
        .location = location,
        .comment = comment,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->new_name);
    rb_gc_register_address(&instance->old_name);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->comment);

    return instance;
}

rbs_ast_declarations_type_alias_t *rbs_ast_declarations_type_alias_new(VALUE name, VALUE type_params, VALUE type, VALUE annotations, VALUE location, VALUE comment) {
    rbs_ast_declarations_type_alias_t *instance = malloc(sizeof(rbs_ast_declarations_type_alias_t));

    *instance = (rbs_ast_declarations_type_alias_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_DECLARATIONS_TYPE_ALIAS
        },
        .name = name,
        .type_params = type_params,
        .type = type,
        .annotations = annotations,
        .location = location,
        .comment = comment,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->type_params);
    rb_gc_register_address(&instance->type);
    rb_gc_register_address(&instance->annotations);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->comment);

    return instance;
}

rbs_ast_directives_use_t *rbs_ast_directives_use_new(VALUE clauses, VALUE location) {
    rbs_ast_directives_use_t *instance = malloc(sizeof(rbs_ast_directives_use_t));

    *instance = (rbs_ast_directives_use_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_DIRECTIVES_USE
        },
        .clauses = clauses,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->clauses);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_ast_directives_use_single_clause_t *rbs_ast_directives_use_single_clause_new(VALUE type_name, VALUE new_name, VALUE location) {
    rbs_ast_directives_use_single_clause_t *instance = malloc(sizeof(rbs_ast_directives_use_single_clause_t));

    *instance = (rbs_ast_directives_use_single_clause_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_DIRECTIVES_USE_SINGLE_CLAUSE
        },
        .type_name = type_name,
        .new_name = new_name,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->type_name);
    rb_gc_register_address(&instance->new_name);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_ast_directives_use_wildcard_clause_t *rbs_ast_directives_use_wildcard_clause_new(VALUE namespace, VALUE location) {
    rbs_ast_directives_use_wildcard_clause_t *instance = malloc(sizeof(rbs_ast_directives_use_wildcard_clause_t));

    *instance = (rbs_ast_directives_use_wildcard_clause_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_DIRECTIVES_USE_WILDCARD_CLAUSE
        },
        .namespace = namespace,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->namespace);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_ast_members_alias_t *rbs_ast_members_alias_new(VALUE new_name, VALUE old_name, VALUE kind, VALUE annotations, VALUE location, VALUE comment) {
    rbs_ast_members_alias_t *instance = malloc(sizeof(rbs_ast_members_alias_t));

    *instance = (rbs_ast_members_alias_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_MEMBERS_ALIAS
        },
        .new_name = new_name,
        .old_name = old_name,
        .kind = kind,
        .annotations = annotations,
        .location = location,
        .comment = comment,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->new_name);
    rb_gc_register_address(&instance->old_name);
    rb_gc_register_address(&instance->kind);
    rb_gc_register_address(&instance->annotations);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->comment);

    return instance;
}

rbs_ast_members_attr_accessor_t *rbs_ast_members_attr_accessor_new(VALUE name, VALUE type, VALUE ivar_name, VALUE kind, VALUE annotations, VALUE location, VALUE comment, VALUE visibility) {
    rbs_ast_members_attr_accessor_t *instance = malloc(sizeof(rbs_ast_members_attr_accessor_t));

    *instance = (rbs_ast_members_attr_accessor_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_MEMBERS_ATTR_ACCESSOR
        },
        .name = name,
        .type = type,
        .ivar_name = ivar_name,
        .kind = kind,
        .annotations = annotations,
        .location = location,
        .comment = comment,
        .visibility = visibility,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->type);
    rb_gc_register_address(&instance->ivar_name);
    rb_gc_register_address(&instance->kind);
    rb_gc_register_address(&instance->annotations);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->comment);
    rb_gc_register_address(&instance->visibility);

    return instance;
}

rbs_ast_members_attr_reader_t *rbs_ast_members_attr_reader_new(VALUE name, VALUE type, VALUE ivar_name, VALUE kind, VALUE annotations, VALUE location, VALUE comment, VALUE visibility) {
    rbs_ast_members_attr_reader_t *instance = malloc(sizeof(rbs_ast_members_attr_reader_t));

    *instance = (rbs_ast_members_attr_reader_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_MEMBERS_ATTR_READER
        },
        .name = name,
        .type = type,
        .ivar_name = ivar_name,
        .kind = kind,
        .annotations = annotations,
        .location = location,
        .comment = comment,
        .visibility = visibility,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->type);
    rb_gc_register_address(&instance->ivar_name);
    rb_gc_register_address(&instance->kind);
    rb_gc_register_address(&instance->annotations);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->comment);
    rb_gc_register_address(&instance->visibility);

    return instance;
}

rbs_ast_members_attr_writer_t *rbs_ast_members_attr_writer_new(VALUE name, VALUE type, VALUE ivar_name, VALUE kind, VALUE annotations, VALUE location, VALUE comment, VALUE visibility) {
    rbs_ast_members_attr_writer_t *instance = malloc(sizeof(rbs_ast_members_attr_writer_t));

    *instance = (rbs_ast_members_attr_writer_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_MEMBERS_ATTR_WRITER
        },
        .name = name,
        .type = type,
        .ivar_name = ivar_name,
        .kind = kind,
        .annotations = annotations,
        .location = location,
        .comment = comment,
        .visibility = visibility,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->type);
    rb_gc_register_address(&instance->ivar_name);
    rb_gc_register_address(&instance->kind);
    rb_gc_register_address(&instance->annotations);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->comment);
    rb_gc_register_address(&instance->visibility);

    return instance;
}

rbs_ast_members_class_instance_variable_t *rbs_ast_members_class_instance_variable_new(VALUE name, VALUE type, VALUE location, VALUE comment) {
    rbs_ast_members_class_instance_variable_t *instance = malloc(sizeof(rbs_ast_members_class_instance_variable_t));

    *instance = (rbs_ast_members_class_instance_variable_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_MEMBERS_CLASS_INSTANCE_VARIABLE
        },
        .name = name,
        .type = type,
        .location = location,
        .comment = comment,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->type);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->comment);

    return instance;
}

rbs_ast_members_class_variable_t *rbs_ast_members_class_variable_new(VALUE name, VALUE type, VALUE location, VALUE comment) {
    rbs_ast_members_class_variable_t *instance = malloc(sizeof(rbs_ast_members_class_variable_t));

    *instance = (rbs_ast_members_class_variable_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_MEMBERS_CLASS_VARIABLE
        },
        .name = name,
        .type = type,
        .location = location,
        .comment = comment,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->type);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->comment);

    return instance;
}

rbs_ast_members_extend_t *rbs_ast_members_extend_new(VALUE name, VALUE args, VALUE annotations, VALUE location, VALUE comment) {
    rbs_ast_members_extend_t *instance = malloc(sizeof(rbs_ast_members_extend_t));

    *instance = (rbs_ast_members_extend_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_MEMBERS_EXTEND
        },
        .name = name,
        .args = args,
        .annotations = annotations,
        .location = location,
        .comment = comment,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->args);
    rb_gc_register_address(&instance->annotations);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->comment);

    return instance;
}

rbs_ast_members_include_t *rbs_ast_members_include_new(VALUE name, VALUE args, VALUE annotations, VALUE location, VALUE comment) {
    rbs_ast_members_include_t *instance = malloc(sizeof(rbs_ast_members_include_t));

    *instance = (rbs_ast_members_include_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_MEMBERS_INCLUDE
        },
        .name = name,
        .args = args,
        .annotations = annotations,
        .location = location,
        .comment = comment,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->args);
    rb_gc_register_address(&instance->annotations);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->comment);

    return instance;
}

rbs_ast_members_instance_variable_t *rbs_ast_members_instance_variable_new(VALUE name, VALUE type, VALUE location, VALUE comment) {
    rbs_ast_members_instance_variable_t *instance = malloc(sizeof(rbs_ast_members_instance_variable_t));

    *instance = (rbs_ast_members_instance_variable_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_MEMBERS_INSTANCE_VARIABLE
        },
        .name = name,
        .type = type,
        .location = location,
        .comment = comment,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->type);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->comment);

    return instance;
}

rbs_ast_members_method_definition_t *rbs_ast_members_method_definition_new(VALUE name, VALUE kind, VALUE overloads, VALUE annotations, VALUE location, VALUE comment, VALUE overloading, VALUE visibility) {
    rbs_ast_members_method_definition_t *instance = malloc(sizeof(rbs_ast_members_method_definition_t));

    *instance = (rbs_ast_members_method_definition_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_MEMBERS_METHOD_DEFINITION
        },
        .name = name,
        .kind = kind,
        .overloads = overloads,
        .annotations = annotations,
        .location = location,
        .comment = comment,
        .overloading = overloading,
        .visibility = visibility,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->kind);
    rb_gc_register_address(&instance->overloads);
    rb_gc_register_address(&instance->annotations);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->comment);
    rb_gc_register_address(&instance->overloading);
    rb_gc_register_address(&instance->visibility);

    return instance;
}

rbs_ast_members_method_definition_overload_t *rbs_ast_members_method_definition_overload_new(VALUE annotations, VALUE method_type) {
    rbs_ast_members_method_definition_overload_t *instance = malloc(sizeof(rbs_ast_members_method_definition_overload_t));

    *instance = (rbs_ast_members_method_definition_overload_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_MEMBERS_METHOD_DEFINITION_OVERLOAD
        },
        .annotations = annotations,
        .method_type = method_type,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->annotations);
    rb_gc_register_address(&instance->method_type);

    return instance;
}

rbs_ast_members_prepend_t *rbs_ast_members_prepend_new(VALUE name, VALUE args, VALUE annotations, VALUE location, VALUE comment) {
    rbs_ast_members_prepend_t *instance = malloc(sizeof(rbs_ast_members_prepend_t));

    *instance = (rbs_ast_members_prepend_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_MEMBERS_PREPEND
        },
        .name = name,
        .args = args,
        .annotations = annotations,
        .location = location,
        .comment = comment,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->args);
    rb_gc_register_address(&instance->annotations);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->comment);

    return instance;
}

rbs_ast_members_private_t *rbs_ast_members_private_new(VALUE location) {
    rbs_ast_members_private_t *instance = malloc(sizeof(rbs_ast_members_private_t));

    *instance = (rbs_ast_members_private_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_MEMBERS_PRIVATE
        },
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_ast_members_public_t *rbs_ast_members_public_new(VALUE location) {
    rbs_ast_members_public_t *instance = malloc(sizeof(rbs_ast_members_public_t));

    *instance = (rbs_ast_members_public_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_MEMBERS_PUBLIC
        },
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_ast_type_param_t *rbs_ast_type_param_new(VALUE name, VALUE variance, VALUE upper_bound, VALUE default_type, VALUE location) {
    rbs_ast_type_param_t *instance = malloc(sizeof(rbs_ast_type_param_t));

    *instance = (rbs_ast_type_param_t) {
        .base = (rbs_node_t) {
            .type = RBS_AST_TYPE_PARAM
        },
        .name = name,
        .variance = variance,
        .upper_bound = upper_bound,
        .default_type = default_type,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->variance);
    rb_gc_register_address(&instance->upper_bound);
    rb_gc_register_address(&instance->default_type);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_method_type_t *rbs_method_type_new(VALUE type_params, VALUE type, VALUE block, VALUE location) {
    rbs_method_type_t *instance = malloc(sizeof(rbs_method_type_t));

    *instance = (rbs_method_type_t) {
        .base = (rbs_node_t) {
            .type = RBS_METHOD_TYPE
        },
        .type_params = type_params,
        .type = type,
        .block = block,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->type_params);
    rb_gc_register_address(&instance->type);
    rb_gc_register_address(&instance->block);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_namespace_t *rbs_namespace_new(VALUE path, VALUE absolute) {
    rbs_namespace_t *instance = malloc(sizeof(rbs_namespace_t));

    *instance = (rbs_namespace_t) {
        .base = (rbs_node_t) {
            .type = RBS_NAMESPACE
        },
        .path = path,
        .absolute = absolute,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->path);
    rb_gc_register_address(&instance->absolute);

    return instance;
}

rbs_type_name_t *rbs_type_name_new(VALUE namespace, VALUE name) {
    rbs_type_name_t *instance = malloc(sizeof(rbs_type_name_t));

    *instance = (rbs_type_name_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPE_NAME
        },
        .namespace = namespace,
        .name = name,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->namespace);
    rb_gc_register_address(&instance->name);

    return instance;
}

rbs_types_alias_t *rbs_types_alias_new(VALUE name, VALUE args, VALUE location) {
    rbs_types_alias_t *instance = malloc(sizeof(rbs_types_alias_t));

    *instance = (rbs_types_alias_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_ALIAS
        },
        .name = name,
        .args = args,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->args);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_bases_any_t *rbs_types_bases_any_new(VALUE todo, VALUE location) {
    rbs_types_bases_any_t *instance = malloc(sizeof(rbs_types_bases_any_t));

    *instance = (rbs_types_bases_any_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_BASES_ANY
        },
        .todo = todo,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->todo);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_bases_bool_t *rbs_types_bases_bool_new(VALUE location) {
    rbs_types_bases_bool_t *instance = malloc(sizeof(rbs_types_bases_bool_t));

    *instance = (rbs_types_bases_bool_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_BASES_BOOL
        },
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_bases_bottom_t *rbs_types_bases_bottom_new(VALUE location) {
    rbs_types_bases_bottom_t *instance = malloc(sizeof(rbs_types_bases_bottom_t));

    *instance = (rbs_types_bases_bottom_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_BASES_BOTTOM
        },
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_bases_class_t *rbs_types_bases_class_new(VALUE location) {
    rbs_types_bases_class_t *instance = malloc(sizeof(rbs_types_bases_class_t));

    *instance = (rbs_types_bases_class_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_BASES_CLASS
        },
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_bases_instance_t *rbs_types_bases_instance_new(VALUE location) {
    rbs_types_bases_instance_t *instance = malloc(sizeof(rbs_types_bases_instance_t));

    *instance = (rbs_types_bases_instance_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_BASES_INSTANCE
        },
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_bases_nil_t *rbs_types_bases_nil_new(VALUE location) {
    rbs_types_bases_nil_t *instance = malloc(sizeof(rbs_types_bases_nil_t));

    *instance = (rbs_types_bases_nil_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_BASES_NIL
        },
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_bases_self_t *rbs_types_bases_self_new(VALUE location) {
    rbs_types_bases_self_t *instance = malloc(sizeof(rbs_types_bases_self_t));

    *instance = (rbs_types_bases_self_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_BASES_SELF
        },
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_bases_top_t *rbs_types_bases_top_new(VALUE location) {
    rbs_types_bases_top_t *instance = malloc(sizeof(rbs_types_bases_top_t));

    *instance = (rbs_types_bases_top_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_BASES_TOP
        },
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_bases_void_t *rbs_types_bases_void_new(VALUE location) {
    rbs_types_bases_void_t *instance = malloc(sizeof(rbs_types_bases_void_t));

    *instance = (rbs_types_bases_void_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_BASES_VOID
        },
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_block_t *rbs_types_block_new(VALUE type, VALUE required, VALUE self_type) {
    rbs_types_block_t *instance = malloc(sizeof(rbs_types_block_t));

    *instance = (rbs_types_block_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_BLOCK
        },
        .type = type,
        .required = required,
        .self_type = self_type,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->type);
    rb_gc_register_address(&instance->required);
    rb_gc_register_address(&instance->self_type);

    return instance;
}

rbs_types_class_instance_t *rbs_types_class_instance_new(VALUE name, VALUE args, VALUE location) {
    rbs_types_class_instance_t *instance = malloc(sizeof(rbs_types_class_instance_t));

    *instance = (rbs_types_class_instance_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_CLASS_INSTANCE
        },
        .name = name,
        .args = args,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->args);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_class_singleton_t *rbs_types_class_singleton_new(VALUE name, VALUE location) {
    rbs_types_class_singleton_t *instance = malloc(sizeof(rbs_types_class_singleton_t));

    *instance = (rbs_types_class_singleton_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_CLASS_SINGLETON
        },
        .name = name,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_function_t *rbs_types_function_new(VALUE required_positionals, VALUE optional_positionals, VALUE rest_positionals, VALUE trailing_positionals, VALUE required_keywords, VALUE optional_keywords, VALUE rest_keywords, VALUE return_type) {
    rbs_types_function_t *instance = malloc(sizeof(rbs_types_function_t));

    *instance = (rbs_types_function_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_FUNCTION
        },
        .required_positionals = required_positionals,
        .optional_positionals = optional_positionals,
        .rest_positionals = rest_positionals,
        .trailing_positionals = trailing_positionals,
        .required_keywords = required_keywords,
        .optional_keywords = optional_keywords,
        .rest_keywords = rest_keywords,
        .return_type = return_type,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->required_positionals);
    rb_gc_register_address(&instance->optional_positionals);
    rb_gc_register_address(&instance->rest_positionals);
    rb_gc_register_address(&instance->trailing_positionals);
    rb_gc_register_address(&instance->required_keywords);
    rb_gc_register_address(&instance->optional_keywords);
    rb_gc_register_address(&instance->rest_keywords);
    rb_gc_register_address(&instance->return_type);

    return instance;
}

rbs_types_function_param_t *rbs_types_function_param_new(VALUE type, VALUE name, VALUE location) {
    rbs_types_function_param_t *instance = malloc(sizeof(rbs_types_function_param_t));

    *instance = (rbs_types_function_param_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_FUNCTION_PARAM
        },
        .type = type,
        .name = name,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->type);
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_interface_t *rbs_types_interface_new(VALUE name, VALUE args, VALUE location) {
    rbs_types_interface_t *instance = malloc(sizeof(rbs_types_interface_t));

    *instance = (rbs_types_interface_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_INTERFACE
        },
        .name = name,
        .args = args,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->args);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_intersection_t *rbs_types_intersection_new(VALUE types, VALUE location) {
    rbs_types_intersection_t *instance = malloc(sizeof(rbs_types_intersection_t));

    *instance = (rbs_types_intersection_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_INTERSECTION
        },
        .types = types,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->types);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_literal_t *rbs_types_literal_new(VALUE literal, VALUE location) {
    rbs_types_literal_t *instance = malloc(sizeof(rbs_types_literal_t));

    *instance = (rbs_types_literal_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_LITERAL
        },
        .literal = literal,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->literal);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_optional_t *rbs_types_optional_new(VALUE type, VALUE location) {
    rbs_types_optional_t *instance = malloc(sizeof(rbs_types_optional_t));

    *instance = (rbs_types_optional_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_OPTIONAL
        },
        .type = type,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->type);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_proc_t *rbs_types_proc_new(VALUE type, VALUE block, VALUE location, VALUE self_type) {
    rbs_types_proc_t *instance = malloc(sizeof(rbs_types_proc_t));

    *instance = (rbs_types_proc_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_PROC
        },
        .type = type,
        .block = block,
        .location = location,
        .self_type = self_type,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->type);
    rb_gc_register_address(&instance->block);
    rb_gc_register_address(&instance->location);
    rb_gc_register_address(&instance->self_type);

    return instance;
}

rbs_types_record_t *rbs_types_record_new(VALUE all_fields, VALUE location) {
    rbs_types_record_t *instance = malloc(sizeof(rbs_types_record_t));

    *instance = (rbs_types_record_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_RECORD
        },
        .all_fields = all_fields,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->all_fields);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_tuple_t *rbs_types_tuple_new(VALUE types, VALUE location) {
    rbs_types_tuple_t *instance = malloc(sizeof(rbs_types_tuple_t));

    *instance = (rbs_types_tuple_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_TUPLE
        },
        .types = types,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->types);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_union_t *rbs_types_union_new(VALUE types, VALUE location) {
    rbs_types_union_t *instance = malloc(sizeof(rbs_types_union_t));

    *instance = (rbs_types_union_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_UNION
        },
        .types = types,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->types);
    rb_gc_register_address(&instance->location);

    return instance;
}

rbs_types_untyped_function_t *rbs_types_untyped_function_new(VALUE return_type) {
    rbs_types_untyped_function_t *instance = malloc(sizeof(rbs_types_untyped_function_t));

    *instance = (rbs_types_untyped_function_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_UNTYPED_FUNCTION
        },
        .return_type = return_type,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->return_type);

    return instance;
}

rbs_types_variable_t *rbs_types_variable_new(VALUE name, VALUE location) {
    rbs_types_variable_t *instance = malloc(sizeof(rbs_types_variable_t));

    *instance = (rbs_types_variable_t) {
        .base = (rbs_node_t) {
            .type = RBS_TYPES_VARIABLE
        },
        .name = name,
        .location = location,
    };

    // TODO: remove this once we do not use inner Ruby objects in our nodes.
    // We need to mark the fields as live so that the GC doesn't free them until we actually create the Ruby object
    // that will own them. The fields are unmarked in `rbs_struct_to_ruby_value` where we create the final Ruby object
    // and free the intermediate C struct.
    rb_gc_register_address(&instance->name);
    rb_gc_register_address(&instance->location);

    return instance;
}


rbs_node_instance_wrapper_t *rbs_node_instance_wrapper_new(VALUE instance) {
    rbs_node_instance_wrapper_t *instance_wrapper = malloc(sizeof(rbs_node_instance_wrapper_t));

    *instance_wrapper = (rbs_node_instance_wrapper_t) {
        .base = (rbs_node_t) {
            .type = RBS_NODE_INSTANCE_WRAPPER
        },
        .instance = instance
    };

    return instance_wrapper;
}
